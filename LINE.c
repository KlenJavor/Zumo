//-------------------------------------------------------- LINE ------------------------------------------------------------------
// Libraries
//---------------------------------------------------------------------------------------------------------------------------------

#include <project.h> //autogenerated - containg generated header files
#include <stdio.h>   //prints
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <math.h>         //for atan and M_PI function
#include "FreeRTOS.h"     //Real-time operating system kernel for embedded devices
#include "task.h"         ////Real-time operating system kernel for embedded devices
#include "Motor.h"        //Motors
#include "Ultra.h"        //Ultrasound sensor
#include "Nunchuk.h"      //not used
#include "Reflectance.h"  //Refectance sensor - read line
#include "Gyro.h"         //Gyroscope - not used in this code
#include "Accel_magnet.h" //Magnetometer - not used in this code
#include "LSM303D.h"      //Accelerometer
#include "IR.h"           //Infra-red receiver for remote control
#include "Beep.h"         //Sound
#include "mqtt_sender.h"  //Messenger
#include "serial1.h"      //mqtt

#if 1 //1 = execute following code, 0 = skip; usefull when there are more programs in one file

//---------------------------------------------------------------------------------------------------------------------------------
// Prototype functions
//---------------------------------------------------------------------------------------------------------------------------------
void motor_hardleft(uint8 speed, uint32 delay);  //tank turn to left
void motor_hardright(uint8 speed, uint32 delay); //tank turn to right

void zmain(void) //main program
{
    //---------------------------------------------------------------------------------------------------------------------------------
    // Start sensors and motor, define variables
    //---------------------------------------------------------------------------------------------------------------------------------

    motor_start();                 //starts the motor
    motor_forward(0, 0);           //sets motor speed to 0 (out of 255)
    IR_Start();                    //starts infra-red receiver
    reflectance_start();           //starts reflectance sensors
    struct sensors_ ref;           //contains analog values of reflectance sensors
    TickType_t start, end, result; //returns the number of system ticks (=milliseconds) since the program was started
    int line = 0;                  //for counting intersections
    int change = 1;                //1 = white = snsors are currently over white surface, 0 = black = sensors are going over intersection
    int32 lastPosition = 0;        //memory for last position
    int32 norml3;                  //reflectance in range 0-1000
    int32 norml2;
    int32 norml1;
    int32 normr1;
    int32 normr2;
    int32 normr3;

    //---------------------------------------------------------------------------------------------------------------------------------
    // Calibration of reflectance sensors
    //---------------------------------------------------------------------------------------------------------------------------------

    /*Each reflectance sensor measures white and black (very) differently.
    Also every "white" and "black" is different. Readings depend also upon lighting in the room.
    The purpose of reflectance calibration is to find the minimum, maximum and treshold for each reflectance sensor.
    Reflectance values range between 0 and 25000.
    During the calibration moves, also the minimum and maximum acceleration measurements for the x and y axes is collected.
    This will later help to decide, whether an accelerometer reading was due to robot moving itself 
    or due to collision. */

    int i; //for counting moves during calibration

    int32 minl3 = 25000; //minimum values measured by each reflectance sensor during calibration (whitest white)
    int32 minl2 = 25000;
    int32 minl1 = 25000;
    int32 minr1 = 25000;
    int32 minr2 = 25000;
    int32 minr3 = 25000;

    int32 maxl3 = 0; //maximum values measured by each reflectance sensor during calibration (darkest black)
    int32 maxl2 = 0;
    int32 maxl1 = 0;
    int32 maxr1 = 0;
    int32 maxr2 = 0;
    int32 maxr3 = 0;

    int32 trefl3;
    int32 trefr3;
    int32 trefl2;
    int32 trefr2;
    int32 trefl1;
    int32 trefr1;

    while (SW1_Read() == 1) //wait for a press of the black button in the centre of the robot
        vTaskDelay(10);

    for (i = 0; i < 1600; i++) //make 400 turns to the right, 800 to the left and 400 to the right
    {
        if (i > 400 && i <= 1200)
        {
            motor_hardleft(200, 1); //do the moves with tank turn at speed 200 (out of 255) and 1 millisecond delay
            reflectance_read(&ref); //while moving read the raw reflectance data
        }
        else
        {
            motor_hardright(200, 1);
            reflectance_read(&ref);
        }
        if (ref.l3 > maxl3) //find the min and max values l3
            maxl3 = ref.l3;
        if (ref.l3 < minl3)
            minl3 = ref.l3;
        if (ref.l2 > maxl2) //l2
            maxl2 = ref.l2;
        if (ref.l2 < minl2)
            minl2 = ref.l2;
        if (ref.l1 > maxl1) //l1
            maxl1 = ref.l1;
        if (ref.l1 < minl1)
            minl1 = ref.l1;
        if (ref.r1 > maxr1) //r1
            maxr1 = ref.r1;
        if (ref.r1 < minr1)
            minr1 = ref.r1;
        if (ref.r2 > maxr2) //r2
            maxr2 = ref.r2;
        if (ref.r2 < minr2)
            minr2 = ref.r2;
        if (ref.r3 > maxr3) //r3
            maxr3 = ref.r3;
        if (ref.r3 < minr3)
            minr3 = ref.r3;
    }
    trefl3 = (minl3 + maxl3) / 2; //calculate reflectance tresholds as the averadges of min and max for each sensor
    trefr3 = (minr3 + maxr3) / 2;
    trefl2 = (minl2 + maxl2) / 2;
    trefr2 = (minr2 + maxr2) / 2;
    trefl1 = (minl1 + maxl1) / 2;
    trefr1 = (minr1 + maxr1) / 2;
    motor_forward(0, 0); //stop the robot

    //---------------------------------------------------------------------------------------------------------------------------------
    // Wait for button press and go to the first line
    //---------------------------------------------------------------------------------------------------------------------------------

    while (SW1_Read() == 1) //wait for a button press
        vTaskDelay(10);

    while (!(line == 1 && change == 1)) //run loop until line 1 is detecte and sensors are over white (line has been crossed)
    {
        motor_forward(50, 1);   //move forward at speed 50 (out of 255)
        reflectance_read(&ref); //read reflectance

        if (ref.l3 > trefl3 && ref.r3 > trefr3) //if both outer sensor see black
        {
            if (change)
            {
                Beep(200, 200); //sgnal with beep
                change = 0;     //change color to black
                line++;         //increase line by 1
            }
        }
        else //in case both outer sensor are not over black, change color to white(1)
            change = 1;
    }
    motor_forward(0, 0);                 //stop the robot
    print_mqtt("Zumo037/ready", "line"); //send mqtt message signalling you are ready to go

    //---------------------------------------------------------------------------------------------------------------------------------
    // After IR, follow line and stop on intersection
    //---------------------------------------------------------------------------------------------------------------------------------

    const int MAX_SPEED = 200;                                                                                                //Speed used in PID formula
    IR_flush();                                                                                                               //delete quequed IR signals
    IR_wait();                                                                                                                //wait for infra-red signal from any remote control
    start = xTaskGetTickCount();                                                                                              //read time from the moment the progra started (millisecond/system ticks)
    print_mqtt("Zumo037/start", "%d", start);                                                                                 //send message to the broker
    motor_forward(100, 300);                                                                                                 //move away from the black line
    while (!(ref.l3 > trefl3 && ref.r3 > trefr3 && ref.r2 > trefr2 && ref.r1 > trefr1 && ref.l2 > trefl2 && ref.l1 > trefl1)) //ride until you see another intersection
    {
        reflectance_read(&ref); //read reflectance

        /*Check if the readings are not smaller or larger than those during calibration.
        If they were, it would mess up the normalisation done in the next step.*/
        if (ref.l3 > maxl3)
            maxl3 = ref.l3;
        if (ref.l3 < minl3)
            minl3 = ref.l3;
        if (ref.l2 > maxl2)
            maxl2 = ref.l2;
        if (ref.l2 < minl2)
            minl2 = ref.l2;
        if (ref.l1 > maxl1)
            maxl1 = ref.l1;
        if (ref.l1 < minl1)
            minl1 = ref.l1;
        if (ref.r1 > maxr1)
            maxr1 = ref.r1;
        if (ref.r1 < minr1)
            minr1 = ref.r1;
        if (ref.r2 > maxr2)
            maxr2 = ref.r2;
        if (ref.r2 < minr2)
            minr2 = ref.r2;
        if (ref.r3 > maxr3)
            maxr3 = ref.r3;
        if (ref.r3 < minr3)
            minr3 = ref.r3;

        /*Normalise each sensor reading to be between 0 and 1000.
        This is necessary in order to make the readings from different sensors comparable.*/
        norml3 = (ref.l3 - minl3) / ((maxl3 - minl3) / 1000);
        norml2 = (ref.l2 - minl2) / ((maxl2 - minl2) / 1000);
        norml1 = (ref.l1 - minl1) / ((maxl1 - minl1) / 1000);
        normr1 = (ref.r1 - minr1) / ((maxr1 - minr1) / 1000);
        normr2 = (ref.r2 - minr2) / ((maxr2 - minr2) / 1000);
        normr3 = (ref.r3 - minr3) / ((maxr3 - minr3) / 1000);

        /*Calcuate the weighted position.
        The edge sensors have bigger weights which causes sharper turns in case the edge sensor notice the black line
        speedDifference = position / kp + kd * (position - lastPosition). kp and kd were obtained experimentally for given MAX_SPEED, expected position and weights.*/
        float position = (-8000 * norml3 - 4000 * norml2 - 1000 * norml1 + 1000 * normr1 + 4000 * normr2 + 8000 * normr3) / (norml3 + norml2 + norml1 + normr1 + normr2 + normr3);
        float speedDifference = position / 7.0 + 0.3 * (position - lastPosition);

        /*In case all sensors see "white" the robot should return back on the line. 
        The direction of the turn is predicted by the last position.
        Robot keeps sending a message about missing a line until it returns back on the line*/
        if ((lastPosition < (-4000)) && ref.l3 < trefl3 && ref.r3 < trefr3 && ref.r2 < trefr2 && ref.l2 < trefl2 && ref.r1 < trefr1 && ref.l1 < trefl1)
        {
            motor_turn(0, 255, 0);
            end = xTaskGetTickCount();
            print_mqtt("Zumo037/miss", "%d", end);
        }
        else if ((lastPosition > (4000)) && ref.l3 < trefl3 && ref.r3 < trefr3 && ref.r2 < trefr2 && ref.l2 < trefl2 && ref.r1 < trefr1 && ref.l1 < trefl1)
        {
            motor_turn(255, 0, 0);
            end = xTaskGetTickCount();
            print_mqtt("Zumo037/miss", "%d", end);
        }
        else //countinue to use the PID formula
        {
            lastPosition = position; //remember last position

            if (speedDifference > 255) //keep speed difference in reasonable limits so int16 does not overflow
                speedDifference = 255;
            if (speedDifference <= -255)
                speedDifference = -255;

            int16 m1Speed = MAX_SPEED + speedDifference;
            int16 m2Speed = MAX_SPEED - speedDifference;

            if (m1Speed < 0) //set the calculated speeds to be between 0 and MAX_SPEED
                m1Speed = 0;
            if (m2Speed < 0)
                m2Speed = 0;
            if (m1Speed > MAX_SPEED)
                m1Speed = MAX_SPEED;
            if (m2Speed > MAX_SPEED)
                m2Speed = MAX_SPEED;
            motor_turn(m1Speed, m2Speed, 0); //run robot at the calculated speeds
        }
    }
    motor_forward(100, 400); //move away from the black line
    motor_forward(0, 0);     //stop the robot

    //-----------------------------------------------------
    // Cross intersection no.3 and stop
    //-----------------------------------------------------

    while (!(ref.l3 > trefl3 && ref.r3 > trefr3 && ref.r2 > trefr2 && ref.r1 > trefr1 && ref.l2 > trefl2 && ref.l1 > trefl1)) //until arriving at the last intersection
    {
        reflectance_read(&ref);
        if (ref.l1 > trefl1) //follow the line with one sensor
            motor_turn(100, 0, 0);
        else if (ref.l1 <= trefl1)
            motor_turn(0, 100, 0);
        else
            Beep(200, 200);
    }
    //---------------------------------------------------------------------------------------------------------------------------------
    // Send messages about results
    //---------------------------------------------------------------------------------------------------------------------------------

    motor_forward(0, 0);                    //after button press get out of the loop and stop motor
    end = xTaskGetTickCount();              //read time from the start of the proram
    result = (end - start);                 //calculate lenght of the race
    print_mqtt("Zumo037/stop", "%lu", end); //send the values as mqtt messages to the broker
    print_mqtt("Zumo037/time", "%lu", result);
}

//---------------------------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------------------------
void motor_hardright(uint8 speed, uint32 delay)
{
    MotorDirLeft_Write(0);    //left motor moving forward (0)
    MotorDirRight_Write(1);   //right motor moving backward (1)
    PWM_WriteCompare1(speed); //left motor speed
    PWM_WriteCompare2(speed); //right motor speed
    vTaskDelay(delay);        //how long to perform before proceeding to another task (note that if there is no other task to follow, the movement will continue)
}

void motor_hardleft(uint8 speed, uint32 delay)
{
    MotorDirLeft_Write(1);    // set LeftMotor forward mode
    MotorDirRight_Write(0);   // set RightMotor backward mode
    PWM_WriteCompare1(speed); //left motor speed
    PWM_WriteCompare2(speed); //right motor speed
    vTaskDelay(delay);        //how long to perform before proceeding to another task (note that if there is no other task to follow, the movement will continue)
}
#endif