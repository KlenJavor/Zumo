//--------------------------------------------------------- MAZE ------------------------------------------------------------------
// Libraries
//---------------------------------------------------------------------------------------------------------------------------------

#include <project.h> //Autogenerated - containg generated header files
#include <stdio.h>
#include <stdlib.h>
#include "FreeRTOS.h"     //Real-time operating system kernel for embedded devices
#include "task.h"         //Real-time operating system kernel for embedded devices
#include "Motor.h"        //Motors
#include "Ultra.h"        //Ultrasound sensor
#include "Nunchuk.h"      //Nunchuk - not used here
#include "Reflectance.h"  //Refectance sensor - read line
#include "Gyro.h"         //Gyroscope - not used here
#include "Accel_magnet.h" //Magnetometer - not used here
#include "LSM303D.h"      //Accelerometer - not used here
#include "IR.h"           //Infra-red receiver for remote control
#include "Beep.h"         //Sound
#include "mqtt_sender.h"  //Messenger
#include <time.h>
#include <sys/time.h>
#include "serial1.h"
#include <unistd.h>
#include <stdlib.h>

//---------------------------------------------------------------------------------------------------------------------------------
// Global declarations (sorry)
//---------------------------------------------------------------------------------------------------------------------------------

#if 1 //1 = execute following code, 0 = skip; usefull when there are more programs in one file

/*  literals for identifying corrections to the movement: */
typedef enum
{
    STRAIGHT_LINE,
    BACK_OFF,
    CURVE_RIGHT,
    CURVE_LEFT,
    NODE,
    END_PHASE
} correction;

/* definitions for tank turning */
#define TO_LEFT 0
#define TO_RIGHT 1

struct sensors_ dig;

typedef enum direction
{
    NORTH,
    EAST,
    SOUTH,
    WEST
} direction;
/* Struct to hold the x/y coordinates of the robot */
/* The y coordinate range is 1...7
   The x coordinate range is 0..14 */
struct coordinates
{
    uint8 x;
    uint8 y;
};
TickType_t start, end, result; //returns the number of system ticks (=milliseconds) since the program was started

struct nav
{
    struct coordinates pos;
    direction dir;
} robot_nav;

#define U ' '  //unknown node
#define NS '-' // been here in NORTH-SOUTH direction
#define EW '|' // been here in EAST-WEST direction
#define B 'B'  //block
#define T '+'  //visited 2x or more
#define X '.'  //edge

char maze_map[9][17] =
    {{X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, '\0'},
     {X, U, U, U, U, U, U, U, U, U, U, U, U, X, X, X, '\0'},
     {X, U, U, U, U, U, U, U, U, U, U, U, U, U, X, X, '\0'},
     {X, U, U, U, U, U, U, U, U, U, U, U, U, U, U, X, '\0'},
     {NS, U, U, U, U, U, U, U, U, U, U, U, U, U, U, NS, '\0'},
     {X, U, U, U, U, U, U, U, U, U, U, U, U, U, U, X, '\0'},
     {X, U, U, U, U, U, U, U, U, U, U, U, U, U, X, X, '\0'},
     {X, U, U, U, U, U, U, U, U, U, U, U, U, X, X, X, '\0'},
     {X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, '\0'}};

//---------------------------------------------------------------------------------------------------------------------------------
// Function prototypes
//---------------------------------------------------------------------------------------------------------------------------------

int sample_Ultra(void);
void update_map(void);
uint8 check_for_block(void);
direction choose_next_node(void);
uint8 passable_node(struct coordinates *node);
uint8 passable_coodrs(uint8 posx, uint8 posy);
uint8 passable_mark(char mark);
void update_coords(void);
correction follow_line(void);
correction perform_correction(correction ct);
void node_turn(direction dir);
void tank_turn(uint8 dir);

void zmain(void)
{
    //---------------------------------------------------------------------------------------------------------------------------------
    // Start motor, sensors
    //---------------------------------------------------------------------------------------------------------------------------------

    motor_start();                                                       //starts the motor
    motor_forward(0, 0);                                                 //sets motor speed to 0 (out of 255)
    IR_Start();                                                          //starts infra-red receiver
    reflectance_start();                                                 //starts reflectance sensors
    Ultra_Start();                                                       //starts ultrasound sensors
    reflectance_set_threshold(11000, 11000, 11000, 11000, 11000, 11000); //above these valies digital reflectance is considered black (1)

    robot_nav.dir = NORTH; //robot starting position
    robot_nav.pos.x = 4;   //robot starting position
    robot_nav.pos.y = 1;   //robot starting position

    //---------------------------------------------------------------------------------------------------------------------------------
    // Wait for button press and go to the first line
    //---------------------------------------------------------------------------------------------------------------------------------

    while (SW1_Read() == 1) //wait for a button press
        vTaskDelay(10);
    do
    {
        motor_forward(75, 0);
    } while (follow_line() != NODE); //follow line until next node
    motor_forward(125, 125);         //cross the intersection
    motor_forward(0, 0);
    print_mqtt("Zumo037/ready", "maze");

    //---------------------------------------------------------------------------------------------------------------------------------
    // After IR go to the edge of maze
    //---------------------------------------------------------------------------------------------------------------------------------

    IR_flush();
    IR_wait();
    start = xTaskGetTickCount();
    print_mqtt("Zumo037/error", "%lu", end);
    do
    {
        motor_forward(125, 0);
    } while (follow_line() != NODE); //follow line until next node
    motor_forward(0, 0);
    perform_correction(NODE); //cross the intersection

    //---------------------------------------------------------------------------------------------------------------------------------
    // Solve the maze
    //---------------------------------------------------------------------------------------------------------------------------------

    for (;;)
    {
        if (robot_nav.pos.x == 4 && robot_nav.pos.y == 14) //if on the final node
        {
            update_map(); //update position (U, T, B, X, EW, NS)
            perform_correction(END_PHASE); //stop, send messages and exit the program
        }
        update_map(); //update position (U, T, B, X, EW, NS)
        uint8 blocked = true; //true = block ahead, false = no block ahead
        do
        {
            node_turn(choose_next_node()); //choose the next node and turn into it
            blocked = check_for_block(); //check if there is a block and if yes, mark the map
        } while (blocked);

        while (perform_correction(follow_line()) != NODE) //move to chosen node
            ;

        update_coords(); //update position
    }
}

//---------------------------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------------------------

int sample_Ultra(void)
/* returns true if there is an obstacle within react_dist length
   false, if the path forward is clear */
{
#define react_dist 13
#define sample_amount 5
    int values[sample_amount];

    for (int i = 0; i < sample_amount; i++)
    {
        values[i] = Ultra_GetDistance();
    }

    /* sort the array:
       (for such a small sample set, bubble sort suits just fine) */
    for (int i = 0; i < sample_amount - 1; i++)
    {
        for (int j = 0; j < sample_amount - i - 1; j++)
        {
            if (values[j] > values[j + 1])
            {
                int t = values[j + 1];
                values[j + 1] = values[j];
                values[j] = t;
            }
        }
    }

    if (values[sample_amount / 2] < react_dist)
    {

        return true;
    }

    return false;
}

void update_map(void) //add the right mark to a node
{
    uint8 posx = robot_nav.pos.x, posy = robot_nav.pos.y;
    char old_mark = maze_map[posx][posy];

    if (old_mark == U)
    {
        if (robot_nav.dir == NORTH || robot_nav.dir == SOUTH)
            maze_map[posx][posy] = NS;
        else
            maze_map[posx][posy] = EW;
    }
    else if (old_mark == NS || old_mark == EW)
        maze_map[posx][posy] = T;
}

uint8 check_for_block(void) //checks for a block in front and updates map
{
    uint8 posx = robot_nav.pos.x, posy = robot_nav.pos.y;

    if (sample_Ultra())
    {
        switch (robot_nav.dir)
        {
        case NORTH:
            posy++;
            break;
        case EAST:
            posx++;
            break;
        case SOUTH:
            posy--;
            break;
        case WEST:
            posx--;
            break;
        }
        maze_map[posx][posy] = B;
        return true;
    }

    return false;
}

direction choose_next_node(void) //choose_next_node returns the best direction to move to next based on the robot's current knowledge of the maze
{
    uint8 centerx = robot_nav.pos.x;
    uint8 centery = robot_nav.pos.y;

    char n, s, e, w;
    /* init north node mark: */
    n = maze_map[centerx][centery + 1];
    /* init east node mark: */
    e = maze_map[centerx + 1][centery];
    /* init south node mark: */
    s = maze_map[centerx][centery - 1];
    /* init west node mark: */
    w = maze_map[centerx - 1][centery];

    /* prefer unknown nodes: */
    if (n == U)
        return NORTH;
    else if (robot_nav.pos.x < 4 && e == U)
        return EAST;
    else if (robot_nav.pos.x >= 4 && w == U)
        return WEST;
    else if (e == U)
        return EAST;
    else if (w == U)
        return WEST;
    /* however never prefer SOUTH... */
    /* At this point, there are no unknown nodes (other than possibly in south), so check for known nodes first: */
    else if (passable_mark(n))
        return NORTH;
    else if (robot_nav.pos.x < 4 && passable_mark(e))
        return EAST;
    else if (robot_nav.pos.x >= 4 && passable_mark(w))
        return WEST;
    else if (passable_mark(e))
        return EAST;
    else if (passable_mark(w))
        return WEST;
    else if (passable_mark(s) || s == T)
        return SOUTH; /* if nothing else, go SOUTH */
    else
    {
        print_mqtt("Zumo037/error", "error");
        motor_forward(0, 0);
        motor_stop(); /* the robot is stuck and cannot move anymore... */
    }
}

uint8 passable_node(struct coordinates *node) //checks whether the given node in the maze contain a passable node or not
{
    return passable_mark(maze_map[node->x][node->y]);
}

uint8 passable_coodrs(uint8 posx, uint8 posy) //checks whether the given x- and y-coordinates contain a passable node in the maze or not
{
    return passable_mark(maze_map[posx][posy]);
}

uint8 passable_mark(char mark) //checks whether a given mark is passable or not
{
    return (mark == U || mark == NS || mark == EW);
}

void update_coords(void) //update_coords updates the robots position in the maze, based on the direction it last moved to
{
    switch (robot_nav.dir)
    {
    case NORTH:
        robot_nav.pos.y++;
        break;
    case EAST:
        robot_nav.pos.x++;
        break;
    case SOUTH:
        robot_nav.pos.y--;
        break;
    case WEST:
        robot_nav.pos.x--;
        break;
    }
}

correction follow_line(void)
{
    reflectance_digital(&dig);

    /* The following algorithm weighs both sides of the robot by adding together sensor readings for each side
       It uses a distorted weight balance to more precisely identify "tight tracks". */

    int left_sensors = dig.l3 + 2 * dig.l2 + 4 * dig.l1;
    int right_sensors = dig.r3 + 2 * dig.r2 + 4 * dig.r1;
    int position = left_sensors - right_sensors;

    if (left_sensors == 7 || right_sensors == 7)
        return NODE;
    else if (position > 0)
        return CURVE_LEFT;
    else if (position < 0)
        return CURVE_RIGHT;
    else if (left_sensors == 0) /* balance == 0 */
        return BACK_OFF;

    return STRAIGHT_LINE;
}

correction perform_correction(correction corr)
/* make_correction is very similar to the final assignment 1's make_correction with few exceptions.
   Since the beginning and end of the maze solving task are more complicated than those of the
   line following/track driving task, they have been separated into their own correction logic. */
{
    static uint8 move_mem = STRAIGHT_LINE, motor_speed = 125; //checking whether the motors have to be "reset"
    switch (corr)
    {
    case STRAIGHT_LINE:
        motor_forward(motor_speed, 0);
        break;

    case CURVE_LEFT:
        motor_turn(0, motor_speed, 0);
        break;

    case CURVE_RIGHT:
        motor_turn(motor_speed, 0, 0);
        break;

    case BACK_OFF:
        motor_backward(motor_speed, 0);
        break;

    case NODE:
        motor_forward(125, 125);
        motor_forward(0, 0);
        break;

    case END_PHASE:
        node_turn(NORTH);        //turn north (if not already in that direction)
        while (corr != BACK_OFF) //follow line until it srops
        {
            corr = follow_line();
            perform_correction(corr);
        }
        motor_forward(0, 0);
        motor_stop();
        end = xTaskGetTickCount();              //read time from the start of the proram
        result = (end - start);                 //calculate lenght of the fight
        print_mqtt("Zumo037/stop", "%lu", end); //send the values as mqtt messages to the broker
        print_mqtt("Zumo037/time", "%lu", result);

        break;
    }

    if (move_mem != corr)
        motor_forward(0, 0);
    move_mem = corr;
    return corr;
}

void node_turn(direction dir) //make turn based on current direction and chosen direction
{
    if (dir == robot_nav.dir)
        return;

    switch (robot_nav.dir)
    {
    case NORTH:
        if (dir == EAST)
            tank_turn(TO_RIGHT);
        else if (dir == WEST)
            tank_turn(TO_LEFT);
        else
        {
            tank_turn(TO_LEFT);
            tank_turn(TO_LEFT);
        }
        break;

    case EAST:
        if (dir == SOUTH)
            tank_turn(TO_RIGHT);
        else if (dir == NORTH)
            tank_turn(TO_LEFT);
        else
        {
            tank_turn(TO_LEFT);
            tank_turn(TO_LEFT);
        }
        break;

    case SOUTH:
        if (dir == WEST)
            tank_turn(TO_RIGHT);
        else if (dir == EAST)
            tank_turn(TO_LEFT);
        else
        {
            tank_turn(TO_LEFT);
            tank_turn(TO_LEFT);
        }
        break;

    case WEST:
        if (dir == NORTH)
            tank_turn(TO_RIGHT);
        else if (dir == SOUTH)
            tank_turn(TO_LEFT);
        else
        {
            tank_turn(TO_LEFT);
            tank_turn(TO_LEFT);
        }
        break;
    }
    robot_nav.dir = dir;
}

void tank_turn(uint8 dir) //turn with a loop (not delay)
{
    MotorDirLeft_Write((dir == TO_LEFT) ? 1 : 0);  // set LeftMotor direction
    MotorDirRight_Write((dir == TO_LEFT) ? 0 : 1); // set RightMotor direction
    PWM_WriteCompare1(125);
    PWM_WriteCompare2(125);
    vTaskDelay(130);
    reflectance_digital(&dig);
    while (!(dig.l1 == 1 && dig.r1 == 1))
        reflectance_digital(&dig);
    vTaskDelay(7); //Correction to center the robot
    motor_forward(0, 0);
}
#endif