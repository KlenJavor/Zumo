//--------------------------------------------------------- SUMO ------------------------------------------------------------------
// Libraries
//---------------------------------------------------------------------------------------------------------------------------------

#include <project.h> //Autogenerated - containg generated header files
#include <stdio.h>
#include <stdlib.h>
#include "FreeRTOS.h" //Real-time operating system kernel for embedded devices
#include "task.h"     ////Real-time operating system kernel for embedded devices
#include "Motor.h"    //Motors
#include "Ultra.h"    //Ultrasound sensor
#include "Nunchuk.h"
#include "Reflectance.h"  //Refectance sensor - read line
#include "Gyro.h"         //Gyroscope - not used in this code
#include "Accel_magnet.h" //Magnetometer - not used in this code
#include "LSM303D.h"      //Accelerometer
#include "IR.h"           //Infra-red receiver for remote control
#include "Beep.h"         //Sound
#include "mqtt_sender.h"  //Messenger
#include <time.h>
#include <sys/time.h>
#include "serial1.h"
#include <unistd.h>
#include <math.h> //for atan and M_PI function

#if 1 //1 = execute following code, 0 = skip; usefull when there are more programs in one file

//---------------------------------------------------------------------------------------------------------------------------------
// Function prototypes
//---------------------------------------------------------------------------------------------------------------------------------
void motor_hardleft(uint8 speed, uint32 delay);  //tank turn to left
void motor_hardright(uint8 speed, uint32 delay); //tank turn to right

void zmain(void) //main program
{
    //---------------------------------------------------------------------------------------------------------------------------------
    // Start sensors and motor, define variables
    //---------------------------------------------------------------------------------------------------------------------------------

    motor_start();       //starts the motor
    motor_forward(0, 0); //sets motor speed to 0 (out of 255)
    IR_Start();          //starts infra-red receiver
    reflectance_start(); //starts reflectance sensors
    Ultra_Start();       //starts ultrasound sensors
    LSM303D_Start();     //starts accelerometer

    struct sensors_ dig;           //contains analog values of reflectance sensors
    struct accData_ data;          //contains accelerometer data for the x, y and z axes
    TickType_t start, end, result; //returns the number of system ticks (=milliseconds) since the program was started
    int d;                         //for storing distance values obtained by ultrasaund
    int line = 0;                  //for counting intersections
    int color = 1;                 //1 = white = snsors are currently over white surface, 0 = black = sensors are going over intersection
    double x;                      //for calculating arc tangent
    double atan(double x);         //arc tangent function for calculating the angle of collision in radians

    int16 angle = 0;     //angle of collision in degrees in range -90째 - +90째
    int16 trueangle = 0; //angle of collision in degrees in range 0째 - +360째
    int32 lasthit = 0;   //last time when hot was registered

    //---------------------------------------------------------------------------------------------------------------------------------
    // Calibration of reflectance sensors and accelerometer
    //---------------------------------------------------------------------------------------------------------------------------------
    /*
    Each reflectance sensor measures white and black (very) differently.
    Also every "white" and "black" is different. Readings depend also upon lighting in the room.
    The purpose of reflectance calibration is to find the minimum, maximum and treshold for each reflectance sensor.
    Reflectance values range between 0 and 25000.
    During the calibration moves, also the minimum and maximum acceleration measurements for the x and y axes is collected.
    This will later help to decide, whether an accelerometer reading was due to robot moving itself 
    or due to collision.
    Accelerometer values range between -25000 to 30000.
    Movement of the robot at the highest speeds (tank turns and back and forward movements at 255) generate the following response:
    min_acceleration_X = -22410
    min_acceleration_Y = -13785
    max_acceleration_X = 21731
    max_acceleration_Y = 10654
    Setting accelerometer treshold so high would result in almost no collisions being detected.
    For the calibration the robot shall be placed over the trail line along the x axes.
    */

    int i;                                                     //for counting moves during calibration
    int32 min[6] = {25000, 25000, 25000, 25000, 25000, 25000}; //for storing minimum values measured by each reflectance sensor during calibration (whitest white) {l3, l2, l1, r1, r2, r3}
    int32 max[6] = {0, 0, 0, 0, 0, 0};                         //for storing maximum values measured by each reflectance sensor during calibration (darkest black) {l3, l2, l1, r1, r2, r3}
    int32 treshold[6];                                         //reflectance treshold for each sensor: < teshold means white; > treshold means black {l3, l2, l1, r1, r2, r3}
    int16 min_acceleration[2] = {0, 0};                        //for min accelerometer data in x and y axes
    int16 max_acceleration[2] = {0, 0};                        //for max accelerometer data in x and y axes

    while (SW1_Read() == 1) //wait for a press of the black button in the centre of the robot to start the calibration
    {
        vTaskDelay(10);
    }
    for (i = 0; i < 1600; i++) //make 400 turns to the right, 800 to the left and 400 to the right
    {
        if (i > 400 && i <= 1200)
        {
            motor_hardleft(200, 1);  //do the moves with tank turn at speed 200 (out of 255) and 1 millisecond delay
            reflectance_read(&dig);  //while moving read the raw reflectance data
            LSM303D_Read_Acc(&data); //while moving read the accelerometer data data
        }
        else
        {
            motor_hardright(200, 1);
            reflectance_read(&dig);
            LSM303D_Read_Acc(&data);
        }
        if (dig.l1 > max[2]) //find the min and max values l1
            max[2] = dig.l1;
        if (dig.l1 < min[2])
            min[2] = dig.l1;
        if (dig.r1 > max[3]) //r1
            max[3] = dig.r1;
        if (dig.r1 < min[3])
            min[3] = dig.r1;
        if (dig.l2 > max[1]) //l2
            max[1] = dig.l2;
        if (dig.l2 < min[1])
            min[1] = dig.l2;
        if (dig.r2 > max[4]) //r2
            max[4] = dig.r2;
        if (dig.r2 < min[4])
            min[4] = dig.r2;
        if (dig.l3 > max[0]) //l3
            max[0] = dig.l3;
        if (dig.l3 < min[0])
            min[0] = dig.l3;
        if (dig.r3 > max[5]) //r3
            max[5] = dig.r3;
        if (dig.r3 < min[5])
            min[5] = dig.r3;
        if (data.accX > max_acceleration[0]) //accelerometer: x-axes
            max_acceleration[0] = data.accX;
        if (data.accX < min_acceleration[0])
            min_acceleration[0] = data.accX;
        if (data.accY > max_acceleration[1]) //accelerometer x-axes
            max_acceleration[1] = data.accY;
        if (data.accY < min_acceleration[1])
            min_acceleration[1] = data.accY;
    }
    for (i = 0; i < 1000; i++)
    {
        if ((i < 200) || (i > 400 && i < 600) || (i > 800 && i < 1000)) //move quickly back and forward to find accelerometer values along (mainly) the x axes
        {
            motor_forward(230, 0);
            LSM303D_Read_Acc(&data);
        }
        else
        {
            motor_backward(230, 0);
            LSM303D_Read_Acc(&data);
        }
        if (data.accX > max_acceleration[0]) //after each reading check if new min and max were found in x-axes
            max_acceleration[0] = data.accX;
        if (data.accX < min_acceleration[0])
            min_acceleration[0] = data.accX;
        if (data.accY > max_acceleration[1]) //x-axes
            max_acceleration[1] = data.accY;
        if (data.accY < min_acceleration[1])
            min_acceleration[1] = data.accY;
    }
    treshold[0] = (min[0] + max[0]) / 2; //calculate reflectance tresholds as the averadges of min and max for each sensor
    treshold[1] = (min[1] + max[1]) / 2;
    treshold[2] = (min[2] + max[2]) / 2;
    treshold[3] = (min[3] + max[3]) / 2;
    treshold[4] = (min[4] + max[4]) / 2;
    treshold[5] = (min[5] + max[5]) / 2;

    motor_forward(0, 0); //stop the robot

    //---------------------------------------------------------------------------------------------------------------------------------
    // Wait for button press and go to the edge of ring
    //---------------------------------------------------------------------------------------------------------------------------------

    while (SW1_Read() == 1) //wait for a button press
    {
        vTaskDelay(10);
    }
    while (!(line == 1 && color == 1)) //run loop until line 1 is detecte and sensors are over white (line has been crossed)
    {
        motor_forward(50, 0);                             //move forward at speed 50 (out of 255)
        reflectance_read(&dig);                           //read reflectance
        if (dig.l3 > treshold[0] && dig.r3 > treshold[5]) //if both outer sensor see black
        {
            if (color)
            {
                Beep(200, 200); //sgnal with beep
                color = 0;      //change color to black
                line++;         //increase line by 1
            }
        }
        else //in case both outer sensor are not over black, change color to white(1)
            color = 1;
    }
    motor_forward(0, 0);                 //stop the robot
    print_mqtt("Zumo037/ready", "zumo"); //send mqtt message signalling you are ready to fight

    //---------------------------------------------------------------------------------------------------------------------------------
    // After IR, enter into the ring
    //---------------------------------------------------------------------------------------------------------------------------------

    IR_flush();                               //flush memory
    IR_wait();                                //wait for IR signal from (any) remote control
    start = xTaskGetTickCount();              //obtain the time as the number of milliseconds (system ticks) since the program started
    print_mqtt("Zumo037/start", "%d", start); //send the start time as an mqtt message to the broker
    d = Ultra_GetDistance();                  //read dustance with the ultrasound sensor, fist reading might be false positive
    motor_forward(50, 1500);                  //move into the ring
    motor_forward(0, 0);                      //stom the robot

    //---------------------------------------------------------------------------------------------------------------------------------
    // Fight
    //---------------------------------------------------------------------------------------------------------------------------------

    while (SW1_Read() == 1) //until a (black) button is pressed
    {
        reflectance_read(&dig);       //read the reflectance values
        d = Ultra_GetDistance();      //see how far other robots are
        LSM303D_Read_Acc(&data);      //see if there is a collision
        x = data.accX / data.accY;    //use accelerometer data in axes x and y to calculate the arc tangens of the collision
        angle = atan(x) * 180 / M_PI; //transfer from radians to degrees
        if (data.accY > 0)            //arcat gives values -90 - +90; transfer them to 0 - 360
            trueangle = angle + 270;
        else
            trueangle = angle + 90;
        if ((dig.l2 > treshold[1]) || (dig.r2 > treshold[4]) || (dig.l1 > treshold[2]) || (dig.r1 > treshold[3])) //if center or middle sensors see black line
        {
            motor_backward(250, 300);  //go backward, away from the edge or ring, far enough to
            motor_hardright(250, 200); //turn to a new direction and not hit the edge again
        }
        else if (data.accX < min_acceleration[0] - 2000) //else if gets front hit then go forward hard to push the other robot away
        {
            motor_forward(250, 0);     //move forward
            end = xTaskGetTickCount(); //read time from the start of the program
            result = end - start;
            if ((result - lasthit) > 1000)
                print_mqtt("Zumo037/hit", "%d %d", end, trueangle); //send the time and the collision angle as an  mqtt message
            else
                ;
            lasthit = result; //
        }
        else if (data.accX > (max_acceleration[0] + 1000) || data.accY > (max_acceleration[1] + 1000) || data.accY < (min_acceleration[1] - 1000)) //if gets hit from side or back
        {
            motor_hardleft(230, 0);    //make tank turn
            end = xTaskGetTickCount(); //read time from the start of the program
            result = end - start;
            if ((result - lasthit) > 1000)
                print_mqtt("Zumo037/hit", "%d %d", end, trueangle); //send the time and the collision angle as an  mqtt message
            else
                ;
            lasthit = result;
        }
        else if (d < 15)           //if another robot is in sight
            motor_forward(255, 0); //approach it at full speed
        else                       //if nothing else to do
            motor_forward(150, 0); //cruise and look for trouble
    }
    motor_forward(0, 0);                    //after button press get out of the loop and stop motor
    end = xTaskGetTickCount();              //read time from the start of the proram
    result = (end - start);                 //calculate lenght of the fight
    print_mqtt("Zumo037/stop", "%lu", end); //send the values as mqtt messages to the broker
    print_mqtt("Zumo037/time", "%lu", result);
}

//---------------------------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------------------------
void motor_hardright(uint8 speed, uint32 delay)
{
    MotorDirLeft_Write(0);    //left motor moving forward (0)
    MotorDirRight_Write(1);   //right motor moving backward (1)
    PWM_WriteCompare1(speed); //left motor speed
    PWM_WriteCompare2(speed); //right motor speed
    vTaskDelay(delay);        //how long to perform before proceeding to another task (note that if there is no other task to follow, the movement will continue)
}

void motor_hardleft(uint8 speed, uint32 delay)
{
    MotorDirLeft_Write(1);    // set LeftMotor forward mode
    MotorDirRight_Write(0);   // set RightMotor backward mode
    PWM_WriteCompare1(speed); //left motor speed
    PWM_WriteCompare2(speed); //right motor speed
    vTaskDelay(delay);        //how long to perform before proceeding to another task (note that if there is no other task to follow, the movement will continue)
}
#endif