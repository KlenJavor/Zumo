/*
*
 */

//---------------------------------------------------------------------------------------------------------------------------------
// Libraries
//---------------------------------------------------------------------------------------------------------------------------------
#include <project.h> //Autogenerated - containg generated header files
#include <stdio.h>
#include <stdlib.h>
#include "FreeRTOS.h" //Real-time operating system kernel for embedded devices
#include "task.h"     ////Real-time operating system kernel for embedded devices
#include "Motor.h"    //Motors
#include "Ultra.h"    //Ultrasound sensor
#include "Nunchuk.h"
#include "Reflectance.h"  //Refectance sensor
#include "Gyro.h"         //Gyroscope
#include "Accel_magnet.h" //Magnetometer
#include "LSM303D.h"      //Accelerometer
#include "IR.h"           //Infra-red receiver for remote control
#include "Beep.h"         //Sound
#include "mqtt_sender.h"  //Messenger
#include <time.h>
#include <sys/time.h>
#include "serial1.h"
#include <unistd.h>

#if 1 //1 = execute following code, 0 = skip; usefull when there are more programs in one file

//---------------------------------------------------------------------------------------------------------------------------------
// Prototype functions
//---------------------------------------------------------------------------------------------------------------------------------
void motor_hardleft(uint8 speed, uint32 delay);                //tank turn to left
void motor_hardright(uint8 speed, uint32 delay);               //tank turn to right
void motor_rturn(uint32 resultd);                              //turn right until again on line
void motor_lturn(uint32 resultd);                              //turn left until again on line
void maze_turn(int speedL, int speedR, uint32 delay);          //tank turn at the edge lines
void motor_myturn(uint8 l_speed, uint8 r_speed, uint32 delay); //motor_turn with direction set to forward for both motors
void nearest_intersect(uint32 resultd);                        //line-follower intide the maze
void left_hand(uint32 resultd);                                //maze-solver with left hand rule

void zmain(void) //main program
{
    //---------------------------------------------------------------------------------------------------------------------------------
    // Start sensors and motor, define variables
    //---------------------------------------------------------------------------------------------------------------------------------
    motor_start();                                                                                      //starts te motor
    motor_forward(0, 0);                                                                                //sets motor speed to 0
    IR_Start();                                                                                         //starts infra-red receiver
    IR_flush();                                                                                         //flush infra-red receiver
    reflectance_start();                                                                                //starts reflectance sensors
    Ultra_Start();                                                                                      //starts ultrasound sensors
    struct sensors_ ref;                                                                                //contains analog values of reflectance sensors
    struct sensors_ dig;                                                                                //contains digital values of reflectance sensors based on the set treshold
    TickType_t start, end, result, startc, endc, resultc, startb, endb, resultb, startd, endd, resultd; //returns the number of system ticks (=milliseconds) since the program was started 0 - who program, c - finnish line, b - left line (for more info see below in the code)

    int d = 0;            //for storing distance values obtained by ultrasaund
    int i;                //for counting moves during calibration
    int speed = 100;      //used in void maze_turn(int speedL, int speedR, uint32 delay);
    int speedLarge = 100; //used in void maze_turn(int speedL, int speedR, uint32 delay);
    int speedSmall = -50; //used in void maze_turn(int speedL, int speedR, uint32 delay);

    uint16_t pos0l3 = 25000;
    uint16_t pos0l2 = 25000;
    uint16_t pos0l1 = 25000;
    uint16_t pos0r1 = 25000;
    uint16_t pos0r2 = 25000;
    uint16_t pos0r3 = 25000;

    uint16_t pos1l3 = 25000;
    uint16_t pos1l2 = 25000;
    uint16_t pos1l1 = 25000;
    uint16_t pos1r1 = 25000;
    uint16_t pos1r2 = 25000;
    uint16_t pos1r3 = 25000;

    uint16_t pos2l3 = 25000;
    uint16_t pos2l2 = 25000;
    uint16_t pos2l1 = 25000;
    uint16_t pos2r1 = 25000;
    uint16_t pos2r2 = 25000;
    uint16_t pos2r3 = 25000;

    //---------------------------------------------------------------------------------------------------------------------------------
    // Calibration of reflectance sensors - to find treshold for different surfaces
    //---------------------------------------------------------------------------------------------------------------------------------

    uint16_t minl3 = 25000; //for storing minimum values measured by each sensor during calibration (whitest white)
    uint16_t minl2 = 25000;
    uint16_t minl1 = 25000;
    uint16_t minr1 = 25000;
    uint16_t minr2 = 25000;
    uint16_t minr3 = 25000;

    uint16_t maxl3 = 0; //for storing maximum values measured by each sensor during calibration (darkest black)
    uint16_t maxl2 = 0;
    uint16_t maxl1 = 0;
    uint16_t maxr1 = 0;
    uint16_t maxr2 = 0;
    uint16_t maxr3 = 0;

    uint16_t trefl3; //treshold
    uint16_t trefl2;
    uint16_t trefl1;
    uint16_t trefr1;
    uint16_t trefr2;
    uint16_t trefr3;

    while (SW1_Read() == 1) //wait for button press
    {
        vTaskDelay(10);
    }
    for (i = 0; i < 1600; i++) //turn robot to the right, to the left and back to the right in order to ride all the sensors over the back line
    {
        if (i > 400 && i <= 1200)
        {
            motor_hardleft(200, 1);
            reflectance_read(&ref); //read reflectance sensors - digital values; sensors are from left l3, l1, l1, r1, r2, r3
        }
        else
        {
            motor_hardright(200, 1);
            reflectance_read(&ref);
        }
        if (ref.l3 > maxl3) //find the min and max values
        {
            maxl3 = ref.l3;
        }
        if (ref.l3 < minl3)
        {
            minl3 = ref.l3;
        }
        if (ref.l2 > maxl2)
        {
            maxl2 = ref.l2;
        }
        if (ref.l2 < minl2)
        {
            minl2 = ref.l2;
        }
        if (ref.l1 > maxl1)
        {
            maxl1 = ref.l1;
        }
        if (ref.l1 < minl1)
        {
            minl1 = ref.l1;
        }
        if (ref.r1 > maxr1)
        {
            maxr1 = ref.r1;
        }
        if (ref.r1 < minr1)
        {
            minr1 = ref.r1;
        }
        if (ref.r2 > maxr2)
        {
            maxr2 = ref.r2;
        }
        if (ref.r2 < minr2)
        {
            minr2 = ref.r2;
        }
        if (ref.r3 > maxr3)
        {
            maxr3 = ref.r3;
        }
        if (ref.r3 < minr3)
        {
            minr3 = ref.r3;
        }
    }

    trefl3 = (minl3 + maxl3) / 2; //calculate tresholds as the averadges of min and max for each sensor
    trefl2 = (minl2 + maxl2) / 2;
    trefl1 = (minl1 + maxl1) / 2;
    trefr1 = (minr1 + maxr1) / 2;
    trefr2 = (minr2 + maxr2) / 2;
    trefr3 = (minr3 + maxr3) / 2;

    motor_forward(0, 0);                                                       //set motor speed to 0
    reflectance_set_threshold(trefl3, trefl2, trefl1, trefr1, trefr2, trefr3); //set found treshold values with the library Reflectance.h function

    //---------------------------------------------------------------------------------------------------------------------------------
    // Wait for button press and go to the first line (intersection)
    //---------------------------------------------------------------------------------------------------------------------------------

    while (SW1_Read() == 1) //wait for press of button
    {
        vTaskDelay(10);
    }
    reflectance_digital(&dig);         //read reflectance sensors - digital values, first reading may be wrong
    while (dig.l3 == 0 && dig.r3 == 0) //go forward until at least one ow the side sensors sees black (1)
    {
        motor_forward(100, 0);
        reflectance_digital(&dig); //read reflectance sensors - digital values
    }
    startd = xTaskGetTickCount();
    motor_forward(100, 50);
    while (dig.l3 == 1 || dig.r3 == 1) //go forward until at least one ow the side sensors sees black (1)
    {
        motor_forward(100, 0);
        reflectance_digital(&dig); //read reflectance sensors - digital values
    }
    endd = xTaskGetTickCount();
    resultd = (endd - startd) + 50; //+20 because in previous chapter I did motor_forward(100, 20); to be sure that the robot was over the black line
    motor_forward(100, resultd);    //move away from the black line
    motor_forward(0, 0);
    print_mqtt("Zumo044/ready", "maze"); //send a message (will display as "Zumo044/ready maze\n" )

    //---------------------------------------------------------------------------------------------------------------------------------
    // Wait for IR signal from remote control
    //---------------------------------------------------------------------------------------------------------------------------------

    while (SW1_Read() == 1)
    {
        vTaskDelay(10);
    }
    //IR_wait();                                //awaits IR signal from any button on any remote control
    start = xTaskGetTickCount();              //time from the start of the program in milliseconds
    print_mqtt("Zumo044/start", "%d", start); //send a message

    //---------------------------------------------------------------------------------------------------------------------------------
    //  Follow the right edge of the maze until the end of the maze or until an obstacle is found
    //---------------------------------------------------------------------------------------------------------------------------------

    d = Ultra_GetDistance(); //saves distance measured with the ultrasound sensor - already here because first reading might be false positive

    while (1) //loop that runs until it gets to break; giving condition d<15 already here for some reason did not work
    {
        reflectance_digital(&dig); //read reflectance sensors - digital values
        pos0l3 = pos1l3;
        pos0l2 = pos1l2;
        pos0l1 = pos1l1;
        pos0r1 = pos1r1;
        pos0r2 = pos1r2;
        pos0r3 = pos1r3;

        pos1l3 = pos2l3;
        pos1l2 = pos2l2;
        pos1l1 = pos2l1;
        pos1r1 = pos2r1;
        pos1r2 = pos2r2;
        pos1r3 = pos2r3;

        pos2l3 = dig.l3;
        pos2l2 = dig.l2;
        pos2l1 = dig.l1;
        pos2r1 = dig.r1;
        pos2r2 = dig.r2;
        pos2r3 = dig.r3;
        d = Ultra_GetDistance();    //saves distance measured with the ultrasound sensor
        endc = xTaskGetTickCount(); //time from the start of the program in milliseconds
        resultc = (endc - startc);  //time from the last turn - indicates end of maze (it does not see turns executed with line-follower)

        if (pos2l3 == 1 && pos2l2 == 1 && pos2l1 == 1 && pos2r1 == 1 && pos2r2 == 1 && pos2r3 == 1 && dig.l3 == 0 && dig.l2 == 0 && dig.l1 == 0 && dig.r1 == 0 && dig.r2 == 0 && dig.r3 == 0)
        {
            motor_forward(0, 0);                   //set motor speed to 0 (stop the robot)
            end = xTaskGetTickCount();             //time from the start of the program in milliseconds
            result = (end - start);                //time it took to solve the whole maze
            print_mqtt("Zumo044/stop", "%d", end); //send a message
            print_mqtt("Zumo044/time", "%d", result);
            break; //exit thw while loop
        }
        else if (d < 13) //if there is an object detected, closer than 13cm
        {

            while (dig.l1 == 1 || dig.l2 == 1) //turn the robot right so that the center left sensors are off the black line
            {
                motor_hardright(100, 0);   //do tank turn to the right at speed 100 (out of 255)
                reflectance_digital(&dig); //read reflectance sensors - digital values
            }
            while (dig.l1 == 0) //turn the robot right until the center left sensor reaches the new line
            {
                motor_hardright(100, 0);
                reflectance_digital(&dig); //read reflectance sensors - digital values
            }
            motor_forward(0, 0);
            break;
        }

        if (dig.l3 == 0 && dig.l2 == 0 && dig.l1 == 0 && dig.r1 == 0 && dig.r2 == 0 && dig.r3 == 0)
        {
            startc = xTaskGetTickCount();
            maze_turn(speedSmall, speedLarge, 150);
        }
        else if ((dig.r1 == 1 && dig.r2 == 1) || (dig.r3 == 1))
        {
            startc = xTaskGetTickCount();
            maze_turn(speedLarge, speedSmall, 150);
        }

        else if (dig.l1 == 1 && dig.r1 == 1)
        {
            motor_myturn(100, 0, 0);
        }
        else if (dig.l2 == 1 && dig.l1 == 0)
        {
            motor_myturn(0, 100, 0);
        }
        else if (dig.l1 == 1 && dig.r1 == 0)
        {
            motor_forward(speed, 0);
        }
    }
    motor_forward(0, 0);

    //---------------------------------------------------------------------------------------------------------------------------------
    //  1st Left line follower (follows the left edge of the maze until (0,0))
    //---------------------------------------------------------------------------------------------------------------------------------

    while (1)
    {
        reflectance_digital(&dig); //read reflectance sensors - digital values

        if (dig.l3 == 0 && dig.l2 == 0 && dig.l1 == 0 && dig.r1 == 0 && dig.r2 == 0 && dig.r3 == 0)
        {
            maze_turn(speedLarge, speedSmall, 150);
        }
        else if ((dig.l1 == 1 && dig.l2 == 1) || (dig.l3 == 1))
        {
            break;
        }

        else if (dig.l1 == 1 && dig.r1 == 1)
        {
            motor_myturn(0, 100, 0);
        }
        else if (dig.l2 == 1 && dig.l1 == 0)
        {
            motor_myturn(100, 0, 0);
        }
        else if (dig.l1 == 0 && dig.r1 == 1)
        {
            motor_forward(speed, 0);
        }
    }
    motor_forward(0, 0);
    Beep(200, 255);

    //---------------------------------------------------------------------------------------------------------------------------------
    //  Cross intersection
    //---------------------------------------------------------------------------------------------------------------------------------
    motor_forward(100, 2 * resultd);
    Beep(200, 255);

    //---------------------------------------------------------------------------------------------------------------------------------
    //  2nd Left line follower (follows the left edge of the maze until the End)
    //---------------------------------------------------------------------------------------------------------------------------------
    i = 0;
    startb = xTaskGetTickCount();
    resultc = 0;
    resultb = 0;
    while (1)
    {

        reflectance_digital(&dig); //read reflectance sensors - digital values
        d = Ultra_GetDistance();

        endc = xTaskGetTickCount();
        resultc = (endc - startc);
        endb = xTaskGetTickCount();
        resultb = (endb - startb);

        if (resultc > 1000 && resultc < 2000 && resultb > 10000 && dig.l3 == 0 && dig.l2 == 0 && dig.l1 == 0 && dig.r1 == 0 && dig.r2 == 0 && dig.r3 == 0)
        {
            motor_forward(0, 0);
            motor_stop();
            end = xTaskGetTickCount();
            result = (end - start);
            print_mqtt("Zumo044/stop", "%d", end);
            print_mqtt("Zumo044/time", "%d", result);
            Beep(200, 255);
            vTaskDelay(100);
            Beep(200, 255);
            vTaskDelay(100);
            Beep(200, 255);
            vTaskDelay(100);
            break;
        }
        else if (d < 10)
        {
            startc = xTaskGetTickCount();
            left_hand(resultd);
        }

        if (dig.l3 == 0 && dig.l2 == 0 && dig.l1 == 0 && dig.r1 == 0 && dig.r2 == 0 && dig.r3 == 0)
        {
            startc = xTaskGetTickCount();
            maze_turn(speedLarge, speedSmall, 150);
        }
        else if ((dig.l1 == 1 && dig.l2 == 1) || (dig.l3 == 1))
        {
            startc = xTaskGetTickCount();
            maze_turn(speedSmall, speedLarge, 150);
        }

        else if (dig.l1 == 1 && dig.r1 == 1)
        {

            motor_myturn(0, 100, 0);
        }
        else if (dig.l2 == 1 && dig.l1 == 0)
        {
            motor_myturn(100, 0, 0);
        }
        else if (dig.l1 == 0 && dig.r1 == 1)
        {
            motor_forward(speed, 0);
        }
    }
    motor_forward(0, 0);
}
//---------------------------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------------------------

void motor_hardright(uint8 speed, uint32 delay)
{
    MotorDirLeft_Write(0);    //left motor moving forward (0)
    MotorDirRight_Write(1);   //right motor moving backward (1)
    PWM_WriteCompare1(speed); //left motor speed
    PWM_WriteCompare2(speed); //right motor speed
    vTaskDelay(delay);        //how long to perform before proceeding to another task (note that if there is no other task to follow, the movement will continue)
}

void motor_hardleft(uint8 speed, uint32 delay)
{
    MotorDirLeft_Write(1);  // set LeftMotor forward mode
    MotorDirRight_Write(0); // set RightMotor backward mode
    PWM_WriteCompare1(speed);
    PWM_WriteCompare2(speed);
    vTaskDelay(delay);
}

void motor_rturn(uint32 resultd) //Performs right turn until back on line
{
    reflectance_start();
    struct sensors_ dig;
    reflectance_digital(&dig); //read reflectance sensors - digital values
    //Beep(200, 255);
    motor_forward(100, 2 * resultd);

    while (dig.l2 == 1 || dig.l1 == 1)
    {
        motor_hardright(100, 0);
        reflectance_digital(&dig); //read reflectance sensors - digital values
    }

    while (dig.l1 == 0)
    {
        motor_hardright(100, 0);
        reflectance_digital(&dig); //read reflectance sensors - digital values
    }
    motor_forward(0, 0);
}
void motor_lturn(uint32 resultd) //Performs left turn until back on line
{
    reflectance_start();
    struct sensors_ dig;
    reflectance_digital(&dig); //read reflectance sensors - digital values
    //Beep(200, 50);
    motor_forward(100, 2 * resultd);

    while (dig.r2 == 1 || dig.r1 == 1)
    {
        motor_hardleft(100, 0);
        reflectance_digital(&dig); //read reflectance sensors - digital values
    }

    while (dig.r1 == 0)
    {
        motor_hardleft(100, 0);
        reflectance_digital(&dig); //read reflectance sensors - digital values
    }
    motor_forward(0, 0);
}

void maze_turn(int speedL, int speedR, uint32 delay)
{
    if (speedL < 0)
    {
        MotorDirLeft_Write(1);
        speedL = -speedL;
    }
    if (speedR < 0)
    {
        MotorDirRight_Write(1);
        speedR = -speedR;
    }
    PWM_WriteCompare1(speedL);
    PWM_WriteCompare2(speedR);
    vTaskDelay(delay);
}

void motor_myturn(uint8 l_speed, uint8 r_speed, uint32 delay)
{
    MotorDirLeft_Write(0);  // set LeftMotor forward mode
    MotorDirRight_Write(0); // set RightMotor forward mode
    PWM_WriteCompare1(l_speed);
    PWM_WriteCompare2(r_speed);
    vTaskDelay(delay);
}
void nearest_intersect(uint32 resultd)
{
    reflectance_start();
    struct sensors_ dig;
    reflectance_digital(&dig); //read reflectance sensors - digital values

    while (dig.l3 == 1 && dig.r3 == 1)
    {
        reflectance_digital(&dig); //read reflectance sensors - digital values

        if (dig.l1 == 1 && dig.r1 == 0)
        {
            motor_myturn(0, 80, 0);
        }
        else if (dig.l1 == 0 && dig.r1 == 1)
        {
            motor_myturn(80, 0, 0);
        }
        else
        {
            motor_forward(80, 0);
        }
    }
    motor_forward(0, 0);
}

void left_hand(uint32 resultd) //Left hand maze solver (starts after noticing d < 10)
{
    Ultra_Start();
    reflectance_start();
    struct sensors_ dig;
    int d = 0;

    uint16_t pos0l3 = 25000;
    uint16_t pos0l2 = 25000;
    uint16_t pos0l1 = 25000;
    uint16_t pos0r1 = 25000;
    uint16_t pos0r2 = 25000;
    uint16_t pos0r3 = 25000;

    uint16_t pos1l3 = 25000;
    uint16_t pos1l2 = 25000;
    uint16_t pos1l1 = 25000;
    uint16_t pos1r1 = 25000;
    uint16_t pos1r2 = 25000;
    uint16_t pos1r3 = 25000;

    uint16_t pos2l3 = 25000;
    uint16_t pos2l2 = 25000;
    uint16_t pos2l1 = 25000;
    uint16_t pos2r1 = 25000;
    uint16_t pos2r2 = 25000;
    uint16_t pos2r3 = 25000;

    reflectance_digital(&dig); //read reflectance sensors - digital values
    d = Ultra_GetDistance();

    while (1)
    {

        reflectance_digital(&dig); //read reflectance sensors - digital values
        pos0l3 = pos1l3;
        pos0l2 = pos1l2;
        pos0l1 = pos1l1;
        pos0r1 = pos1r1;
        pos0r2 = pos1r2;
        pos0r3 = pos1r3;

        pos1l3 = pos2l3;
        pos1l2 = pos2l2;
        pos1l1 = pos2l1;
        pos1r1 = pos2r1;
        pos1r2 = pos2r2;
        pos1r3 = pos2r3;

        pos2l3 = dig.l3;
        pos2l2 = dig.l2;
        pos2l1 = dig.l1;
        pos2r1 = dig.r1;
        pos2r2 = dig.r2;
        pos2r3 = dig.r3;
        d = Ultra_GetDistance();

        if (pos2l3 == 1 && pos2l2 == 1 && pos2l1 == 1 && pos2r1 == 1 && pos2r2 == 1 && pos2r3 == 1 && dig.l3 == 0 && dig.l2 == 0 && dig.l1 == 0 && dig.r1 == 0 && dig.r2 == 0 && dig.r3 == 0)

        {
            motor_rturn(resultd);
            break;
        }
        if (d < 12)
        {
            motor_rturn(resultd);
            d = Ultra_GetDistance();
            if (d < 12)
            {
                motor_forward(0, 0);
            }
            else
            {
                nearest_intersect(resultd);
                motor_lturn(resultd);
            }
        }
        else
        {
            nearest_intersect(resultd);
        }
    }
}
#endif